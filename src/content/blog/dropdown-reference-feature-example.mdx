---
title: "Dropdown Reference Feature - Keep Content Outside"
description: "Learn how to use the DropdownRef feature to keep lengthy content separate from your dropdown definitions"
date: 2025-10-21
tags: [astro, mdx, react, dropdown, advanced]
category: tutorial
---

import Dropdown, { DropdownOption, DropdownRef } from "@/react/Dropdown/Dropdown.jsx";
import Tabs, { TabItem } from "@/react/Tabs/Tabs.jsx";

# Dropdown Reference Feature (:::drop)

Keep lengthy content outside your dropdown definition for better organization and readability!

## 🎯 Why Use References?

When your dropdown options contain extensive content (long code examples, detailed explanations, multiple sections), it's cleaner to define the content separately:

### ❌ Without References (Messy)
```jsx
<Dropdown client:load>
  <DropdownOption value="javascript" label="JavaScript">
    {/* 500+ lines of content here... */}
    {/* Makes the dropdown definition hard to read */}
  </DropdownOption>
  <DropdownOption value="python" label="Python">
    {/* Another 500+ lines here... */}
  </DropdownOption>
</Dropdown>
```

### ✅ With References (Clean)
```jsx
<Dropdown client:load>
  <DropdownOption value=":::drop javascript" label="JavaScript" />
  <DropdownOption value=":::drop python" label="Python" />
</Dropdown>

{/* Content defined separately below */}
<DropdownRef type="drop" id="javascript">
    <Tabs defaultValue="imp" client:load>
    <TabItem value="basic" label="✅ Basic Example">
        ## Your First Tabs
    </TabItem>
    <TabItem value="imp" label="✅ Imp Example">
        Second Tab
    </TabItem>
    </Tabs>
</DropdownRef>

<DropdownRef type="drop" id="python">
  {/* 500+ lines of content here */}
</DropdownRef>
```

## 📚 Basic Usage Example

<Dropdown stripCss defaultValue=":::drop test" placeholder="Choose language..." client:load>
  <DropdownOption value=":::drop test" label="Testing Tab" />
  <DropdownOption value=":::drop spanish" label="🇪🇸 Español" />
  <DropdownOption value=":::drop french" label="🇫🇷 Français" />
</Dropdown>

<DropdownRef type="drop" id="test">
  <Tabs defaultValue="imp" client:load>
    <TabItem value="basic" label="✅ Basic Example">
      ## Your First Tabs
    </TabItem>
    <TabItem value="imp" label="✅ Imp Example">
      Second Tab
    </TabItem>
  </Tabs>
</DropdownRef>

<DropdownRef type="drop" id="spanish">
## ¡Bienvenido al Sistema de Referencias!

Este contenido está definido **fuera** del componente dropdown usando `<DropdownRef>`.

### Beneficios:
- **Mejor organización** - Mantén las definiciones de dropdown concisas
- **Edición más fácil** - El contenido no está anidado profundamente
- **Reutilización** - Referencia el mismo contenido desde múltiples lugares
- **Código más limpio** - Separa estructura de contenido

### Soporte completo de Markdown:
- Texto en **negrita** y *cursiva*
- `código en línea`
- [Enlaces](https://astro.build)
- ¡Listas y más!

```js title="ejemplo.js"
// ¡Los bloques de código funcionan perfectamente!
const saludo = "¡Hola desde Español!";
console.log(saludo);
```

> 💡 **Consejo:** ¡Usa referencias para cualquier contenido de más de 20-30 líneas!
</DropdownRef>

<DropdownRef type="drop" id="french">
## Bienvenue dans le Système de Références !

Ce contenu est défini **à l'extérieur** du composant dropdown en utilisant `<DropdownRef>`.

### Avantages :
- **Meilleure organisation** - Gardez les définitions de dropdown concises
- **Édition plus facile** - Le contenu n'est pas imbriqué profondément
- **Réutilisabilité** - Référencez le même contenu depuis plusieurs endroits
- **Code plus propre** - Séparez la structure du contenu

### Support complet de Markdown :
- Texte en **gras** et *italique*
- `code en ligne`
- [Liens](https://astro.build)
- Listes et plus !

```js title="exemple.js"
// Les blocs de code fonctionnent parfaitement !
const salutation = "Bonjour depuis le Français !";
console.log(salutation);
```

> 💡 **Astuce :** Utilisez des références pour tout contenu de plus de 20-30 lignes !
</DropdownRef>

## 🔧 How It Works

### Step 1: Define Your Dropdown with References

Use the pattern `:::drop <identifier>` in the `value` prop:

```jsx
<Dropdown defaultValue=":::drop python" client:load>
  <DropdownOption value=":::drop python" label="🐍 Python" />
  <DropdownOption value=":::drop javascript" label="🟨 JavaScript" />
  <DropdownOption value=":::drop typescript" label="🔷 TypeScript" />
</Dropdown>
```

### Step 2: Define Your Content with DropdownRef

Place your content anywhere in the MDX file (usually after the dropdown):

```jsx
<DropdownRef type="drop" id="python">
  ## Python Content
  Your extensive Python content here...
</DropdownRef>

<DropdownRef type="drop" id="javascript">
  ## JavaScript Content
  Your extensive JavaScript content here...
</DropdownRef>

<DropdownRef type="drop" id="typescript">
  ## TypeScript Content
  Your extensive TypeScript content here...
</DropdownRef>
```

### Key Points:
- **Pattern:** `:::drop <id>` in `value` prop
- **Type:** Use `type="drop"` (you can use custom types too)
- **ID:** Must match between `value=":::drop <id>"` and `id="<id>"`
- **Location:** DropdownRef can be anywhere in your MDX file

## 🚀 Advanced Example: Framework Comparison

<Dropdown defaultValue=":::drop react" placeholder="Select framework..." client:load>
  <DropdownOption value=":::drop react" label="⚛️ React" />
  <DropdownOption value=":::drop vue" label="💚 Vue" />
  <DropdownOption value=":::drop svelte" label="🧡 Svelte" />
  <DropdownOption value=":::drop solid" label="🔷 Solid" />
</Dropdown>

<DropdownRef type="drop" id="react">
## React: Component-Based Architecture

React is a JavaScript library for building user interfaces with a component-based architecture.

### Core Concepts

**Components:** Reusable pieces of UI
```jsx title="Button.jsx" showLineNumbers
import React from 'react';

function Button({ label, onClick, variant = 'primary' }) {
  return (
    <button 
      onClick={onClick}
      className={`btn btn-${variant}`}
    >
      {label}
    </button>
  );
}

export default Button;
```

**Hooks:** State and lifecycle management
```jsx title="useCounter.js" showLineNumbers
import { useState, useEffect } from 'react';

function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  const [history, setHistory] = useState([initialValue]);

  useEffect(() => {
    setHistory(prev => [...prev, count]);
  }, [count]);

  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);

  return { count, history, increment, decrement, reset };
}

export default useCounter;
```

**Props:** Passing data between components
```jsx title="UserCard.jsx"
function UserCard({ user }) {
  return (
    <div className="user-card">
      <img src={user.avatar} alt={user.name} />
      <h3>{user.name}</h3>
      <p>{user.email}</p>
      <span className={user.isActive ? 'active' : 'inactive'}>
        {user.isActive ? 'Online' : 'Offline'}
      </span>
    </div>
  );
}
```

### Key Features
- 🎯 **Virtual DOM** - Efficient updates
- 🔄 **Unidirectional data flow** - Predictable state management
- 🧩 **Component composition** - Build complex UIs from simple pieces
- 🎣 **Hooks** - Reusable stateful logic
- 🌐 **Large ecosystem** - Thousands of libraries

### When to Use React
- Building complex single-page applications
- Need a large ecosystem and community
- Want flexibility in state management (Redux, MobX, Zustand)
- Enterprise applications with long-term support
</DropdownRef>

<DropdownRef type="drop" id="vue">
## Vue: The Progressive Framework

Vue.js is a progressive framework for building user interfaces with an intuitive API.

### Core Concepts

**Single File Components (SFC)**
```vue title="Button.vue" showLineNumbers
<template>
  <button 
    @click="handleClick"
    :class="['btn', `btn-${variant}`]"
  >
    {{ label }}
  </button>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue';

const props = defineProps({
  label: String,
  variant: {
    type: String,
    default: 'primary'
  }
});

const emit = defineEmits(['click']);

const handleClick = () => {
  emit('click');
};
</script>

<style scoped>
.btn {
  padding: 10px 20px;
  border-radius: 8px;
  font-weight: 600;
}
</style>
```

**Composition API**
```vue title="useCounter.js" showLineNumbers
import { ref, computed, watch } from 'vue';

export function useCounter(initialValue = 0) {
  const count = ref(initialValue);
  const history = ref([initialValue]);
  
  const doubled = computed(() => count.value * 2);
  
  watch(count, (newCount) => {
    history.value.push(newCount);
  });

  const increment = () => count.value++;
  const decrement = () => count.value--;
  const reset = () => count.value = initialValue;

  return {
    count,
    history,
    doubled,
    increment,
    decrement,
    reset
  };
}
```

**Template Syntax**
```vue title="UserCard.vue"
<template>
  <div class="user-card">
    <img :src="user.avatar" :alt="user.name" />
    <h3>{{ user.name }}</h3>
    <p>{{ user.email }}</p>
    <span :class="user.isActive ? 'active' : 'inactive'">
      {{ user.isActive ? 'Online' : 'Offline' }}
    </span>
  </div>
</template>

<script setup>
defineProps({
  user: Object
});
</script>
```

### Key Features
- 📝 **Template syntax** - Intuitive HTML-like templates
- ⚡ **Reactive system** - Automatic dependency tracking
- 🎨 **Scoped CSS** - Component-level styling
- 🔧 **Two-way binding** - v-model directive
- 📦 **Built-in tooling** - Official router, state management

### When to Use Vue
- Building applications of any size (progressive)
- Want intuitive, easy-to-learn syntax
- Need official solutions for routing and state
- Prefer template-based approach
- Solo developers or small teams
</DropdownRef>

<DropdownRef type="drop" id="svelte">
## Svelte: Truly Reactive Framework

Svelte is a radical new approach that shifts work into compile time rather than running in the browser.

### Core Concepts

**Components**
```svelte title="Button.svelte" showLineNumbers
<script>
  export let label = 'Click me';
  export let variant = 'primary';
  
  function handleClick() {
    console.log('Button clicked!');
  }
</script>

<button 
  on:click={handleClick}
  class="btn btn-{variant}"
>
  {label}
</button>

<style>
  .btn {
    padding: 10px 20px;
    border-radius: 8px;
    font-weight: 600;
  }
  
  .btn-primary {
    background: #3b82f6;
    color: white;
  }
</style>
```

**Reactivity**
```svelte title="Counter.svelte" showLineNumbers
<script>
  let count = 0;
  let history = [0];
  
  // Reactive declaration
  $: doubled = count * 2;
  $: tripled = count * 3;
  
  // Reactive statement
  $: {
    console.log(`Count is now ${count}`);
    history = [...history, count];
  }
  
  function increment() {
    count += 1;
  }
  
  function decrement() {
    count -= 1;
  }
  
  function reset() {
    count = 0;
  }
</script>

<div class="counter">
  <p>Count: {count}</p>
  <p>Doubled: {doubled}</p>
  <p>Tripled: {tripled}</p>
  
  <button on:click={decrement}>-1</button>
  <button on:click={reset}>Reset</button>
  <button on:click={increment}>+1</button>
  
  <p>History: {history.join(', ')}</p>
</div>
```

**Stores (State Management)**
```js title="stores.js" showLineNumbers
import { writable, derived } from 'svelte/store';

export const count = writable(0);

export const doubled = derived(count, $count => $count * 2);

// Custom store with methods
function createCounter() {
  const { subscribe, set, update } = writable(0);
  
  return {
    subscribe,
    increment: () => update(n => n + 1),
    decrement: () => update(n => n - 1),
    reset: () => set(0)
  };
}

export const counter = createCounter();
```

### Key Features
- ⚡ **No virtual DOM** - Compiles to efficient vanilla JS
- 🎯 **True reactivity** - Simple `$:` syntax
- 📦 **Small bundle size** - No runtime overhead
- 🎨 **Scoped styles** - Built-in component styling
- 🔄 **Stores** - Built-in state management
- 🚀 **Fast** - Among the fastest frameworks

### When to Use Svelte
- Need optimal performance and small bundles
- Building interactive components or widgets
- Want simple, intuitive syntax
- Don't need a massive ecosystem
- Startups and modern web apps
</DropdownRef>

<DropdownRef type="drop" id="solid">
## Solid: Fine-Grained Reactivity

SolidJS delivers React-like syntax with fine-grained reactivity for optimal performance.

### Core Concepts

**Components**
```jsx title="Button.jsx" showLineNumbers
import { splitProps } from 'solid-js';

function Button(props) {
  const [local, others] = splitProps(props, ['label', 'variant']);
  
  return (
    <button 
      class={`btn btn-${local.variant || 'primary'}`}
      {...others}
    >
      {local.label || 'Click me'}
    </button>
  );
}

export default Button;
```

**Signals**
```jsx title="Counter.jsx" showLineNumbers
import { createSignal, createEffect, createMemo } from 'solid-js';

function Counter() {
  const [count, setCount] = createSignal(0);
  const [history, setHistory] = createSignal([0]);
  
  // Memoized computed value
  const doubled = createMemo(() => count() * 2);
  const tripled = createMemo(() => count() * 3);
  
  // Side effect
  createEffect(() => {
    console.log(`Count changed to: ${count()}`);
    setHistory(prev => [...prev, count()]);
  });
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(0);
  
  return (
    <div class="counter">
      <p>Count: {count()}</p>
      <p>Doubled: {doubled()}</p>
      <p>Tripled: {tripled()}</p>
      
      <button onClick={decrement}>-1</button>
      <button onClick={reset}>Reset</button>
      <button onClick={increment}>+1</button>
      
      <p>History: {history().join(', ')}</p>
    </div>
  );
}

export default Counter;
```

**Stores**
```jsx title="counterStore.js" showLineNumbers
import { createStore } from 'solid-js/store';

function createCounterStore() {
  const [state, setState] = createStore({
    count: 0,
    history: [0]
  });
  
  const increment = () => {
    setState('count', c => c + 1);
    setState('history', h => [...h, state.count + 1]);
  };
  
  const decrement = () => {
    setState('count', c => c - 1);
    setState('history', h => [...h, state.count - 1]);
  };
  
  const reset = () => {
    setState({ count: 0, history: [0] });
  };
  
  return { state, increment, decrement, reset };
}

export default createCounterStore;
```

**Control Flow**
```jsx title="UserList.jsx"
import { For, Show, Switch, Match } from 'solid-js';

function UserList(props) {
  return (
    <div>
      <Show when={props.users.length > 0} fallback={<p>No users found</p>}>
        <For each={props.users}>
          {(user) => (
            <div class="user-card">
              <h3>{user.name}</h3>
              <p>{user.email}</p>
              <Switch>
                <Match when={user.role === 'admin'}>
                  <span class="badge-admin">Admin</span>
                </Match>
                <Match when={user.role === 'moderator'}>
                  <span class="badge-mod">Moderator</span>
                </Match>
                <Match when={user.role === 'user'}>
                  <span class="badge-user">User</span>
                </Match>
              </Switch>
            </div>
          )}
        </For>
      </Show>
    </div>
  );
}
```

### Key Features
- ⚡ **Fine-grained reactivity** - Updates only what changed
- 🚀 **Blazing fast** - No virtual DOM overhead
- ⚛️ **React-like syntax** - Familiar developer experience
- 🎯 **Signals** - Primitive reactive values
- 🔄 **Stores** - Nested reactive objects
- 📦 **Small bundle** - Efficient compilation

### When to Use Solid
- Need maximum performance
- Like React syntax but want better performance
- Building high-performance dashboards
- Real-time applications
- Want fine-grained control over reactivity
</DropdownRef>

## 💡 Best Practices

### 1. Organize Your Content

Keep dropdown definitions at the top, content references at the bottom:

```jsx
// ✅ Good Structure
<Dropdown client:load>
  <DropdownOption value=":::drop opt1" label="Option 1" />
  <DropdownOption value=":::drop opt2" label="Option 2" />
</Dropdown>

{/* Regular content here */}

{/* All references at the end */}
<DropdownRef type="drop" id="opt1">
  Content...
</DropdownRef>

<DropdownRef type="drop" id="opt2">
  Content...
</DropdownRef>
```

### 2. Use Descriptive IDs

```jsx
// ❌ Bad
<DropdownOption value=":::drop a" label="JavaScript" />
<DropdownRef type="drop" id="a">...</DropdownRef>

// ✅ Good
<DropdownOption value=":::drop javascript-guide" label="JavaScript" />
<DropdownRef type="drop" id="javascript-guide">...</DropdownRef>
```

### 3. When to Use References

**Use references when:**
- Content is longer than 30 lines
- Multiple code blocks per option
- Complex Markdown structures
- Want better organization

**Use inline when:**
- Content is short (< 20 lines)
- Simple text or single code block
- Quick examples

### 4. Custom Reference Types

You can use custom types for different content categories:

```jsx
// Code examples
<DropdownOption value=":::code python" label="Python" />
<DropdownRef type="code" id="python">...</DropdownRef>

// Documentation
<DropdownOption value=":::docs api-v2" label="API v2" />
<DropdownRef type="docs" id="api-v2">...</DropdownRef>

// Tutorials
<DropdownOption value=":::tutorial beginner" label="Beginner" />
<DropdownRef type="tutorial" id="beginner">...</DropdownRef>
```

## 🎨 Mixed Usage Example

You can mix inline content with references:

<Dropdown defaultValue="inline" client:load>
  <DropdownOption value="inline" label="📝 Inline Content">
    ## This is Inline
    
    Short content can stay inline for quick examples.
    
    ```js
    console.log("Quick example");
    ```
  </DropdownOption>
  <DropdownOption value=":::drop reference" label="🔗 Referenced Content" />
</Dropdown>

<DropdownRef type="drop" id="reference">
## This is Referenced Content

For longer, more complex content, use references to keep things organized.

### Multiple Sections

You can have many sections, code blocks, and detailed explanations without cluttering your dropdown definition.

```js title="complex-example.js" showLineNumbers
// Long code example 1
function fetchData(url) {
  return fetch(url)
    .then(response => response.json())
    .catch(error => console.error('Error:', error));
}
```

```js title="complex-example-2.js" showLineNumbers
// Long code example 2
async function processData(data) {
  const processed = data.map(item => ({
    ...item,
    timestamp: new Date().toISOString()
  }));
  
  return processed;
}
```

### Tables Work Too

| Feature | Inline | Referenced |
|---------|--------|------------|
| Short content | ✅ Perfect | ⚠️ Overkill |
| Long content | ❌ Messy | ✅ Perfect |
| Organization | ⚠️ OK | ✅ Excellent |

> 💡 **Tip:** Use the approach that makes your MDX file easiest to maintain!
</DropdownRef>

## 🎯 Summary

The DropdownRef feature gives you:

✅ **Better organization** - Separate structure from content  
✅ **Cleaner code** - Dropdown definitions stay concise  
✅ **Flexibility** - Mix inline and referenced content  
✅ **Maintainability** - Easy to find and edit content  
✅ **Custom types** - Organize by content category  

### Quick Reference

```jsx
// 1. Define dropdown with reference pattern
<Dropdown defaultValue=":::drop first" client:load>
  <DropdownOption value=":::drop first" label="First" />
  <DropdownOption value=":::drop second" label="Second" />
</Dropdown>

// 2. Define content with DropdownRef
<DropdownRef type="drop" id="first">
  Your content here...
</DropdownRef>

<DropdownRef type="drop" id="second">
  More content here...
</DropdownRef>
```

Start using references today for better organized, more maintainable MDX content! 🚀