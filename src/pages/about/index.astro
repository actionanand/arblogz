---
import IndexPage from "@/layouts/IndexPage.astro";
import {t} from '@/i18n/utils';

const frontmatter = {
  donate: true,
  comment: false
};

// Function to process markdown-like syntax
function processMarkdown(text: string): string {
  return text.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
}
---

<IndexPage frontmatter={frontmatter}>
  <article class="markdown-body">
    <h2 data-translate="about.website.title">{t('about.website.title')}</h2>
    <p data-translate="about.website.content">{t('about.website.content')}</p>

    <h2 data-translate="about.me.title">{t('about.me.title')}</h2>
    <p data-translate="about.me.content">{t('about.me.content')}</p>

    <h2 data-translate="about.other.title">{t('about.other.title')}</h2>
    <p data-translate="about.other.content" set:html={processMarkdown(t('about.other.content'))}></p>
    
    <!-- Debug test -->
    <p>Test: <span data-translate="nav.about">{t('nav.about')}</span> | <span data-translate="home.readMore">{t('home.readMore')}</span></p>
  </article>
</IndexPage>

<script>
  // Client-side translation update for about page
  function updateAboutTranslations() {
    // Force reload translations to ensure about keys are available
    const windowWithTranslation = window as any;
    if (typeof window !== 'undefined' && windowWithTranslation.getCurrentTranslation) {
      const elements = document.querySelectorAll('[data-translate]');
      elements.forEach(element => {
        const key = element.getAttribute('data-translate');
        if (key) {
          try {
            const translation = windowWithTranslation.getCurrentTranslation(key);
            if (translation && translation !== key) { // Make sure we got a real translation, not the key back
              if (key === 'about.other.content') {
                // Process markdown for bold text
                element.innerHTML = translation.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
              } else {
                element.textContent = translation;
              }
            } else {
              // Fallback: try direct key lookup
              console.log('Translation not found for key:', key);
            }
          } catch (error) {
            console.log('Error translating key:', key, error);
          }
        }
      });
    }
  }

  // Ensure translations are loaded before updating
  function waitForTranslationsAndUpdate() {
    let attempts = 0;
    const maxAttempts = 10;
    
    function tryUpdate() {
      attempts++;
      const windowWithTranslation = window as any;
      if (windowWithTranslation.getCurrentTranslation) {
        // Test if our specific about keys are available
        const testKey = windowWithTranslation.getCurrentTranslation('about.website.title');
        if (testKey && testKey !== 'about.website.title') {
          updateAboutTranslations();
          return;
        }
      }
      
      if (attempts < maxAttempts) {
        setTimeout(tryUpdate, 200);
      } else {
        console.log('About page translations not loaded after', maxAttempts, 'attempts');
      }
    }
    
    tryUpdate();
  }

  // Update translations when page loads
  document.addEventListener('DOMContentLoaded', function() {
    setTimeout(waitForTranslationsAndUpdate, 100);
  });
  
  // Update translations when language changes
  document.addEventListener('languageChanged', function() {
    setTimeout(waitForTranslationsAndUpdate, 100);
  });
  
  // Listen for language selector clicks
  document.addEventListener('click', function(e) {
    const target = e.target as HTMLElement;
    if (target && target.closest('[data-language-link]')) {
      setTimeout(waitForTranslationsAndUpdate, 300);
    }
  });

  // Additional backup - listen for storage changes (language preference)
  window.addEventListener('storage', function(e) {
    if (e.key === 'language') {
      setTimeout(waitForTranslationsAndUpdate, 200);
    }
  });

  // Force update after a longer delay as final fallback
  setTimeout(waitForTranslationsAndUpdate, 1000);
</script>
